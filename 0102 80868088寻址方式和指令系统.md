[toc]

从汇编语言程序设计的角度看，8086/8088、80186没有多大差异，而Intel的80x86指令系统向上兼容，==本章介绍8086/8088寻址方式和指令系统==

# 2.1 8086/8088寄存器组

## 2.1.1 8086/8088 CPU寄存器组

包含：4个数据寄存器，2个16位指针寄存器，2个16位变址寄存器，1个指令指针，4个16位段寄存器，1个16位标志寄存器

将他们分成4组，如图：

![image-20221128132815920](./0102%2080868088%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%92%8C%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.assets/image-20221128132815920.png)

### 1 通用寄存器

==数据寄存器、指针寄存器、变址寄存器统称为通用寄存器。他们均可以用于传送和暂存数据，可用于保存算数逻辑运算终端的操作数和运算结果==

各通用寄存器的用途如下：

![image-20221128133422922](./0102%2080868088%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%92%8C%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.assets/image-20221128133422922.png)

#### 数据寄存器

数据寄存器主要用来保存操作数或运算结果等信息

==AH就是AX的高八位，AL就是AX的低八位，其余三个一次类推==

==AX和AL寄存器又称为累加器(Accumulator)。一般通过累加器所花的时间最少==

==BX寄存器又称基(Base)地址寄存器。它是四个数据寄存器中唯一可以作为寄存器指针使用的寄存器==

==CX寄存器又称计数(Count)寄存器。==在字符串操作和循环操作时，用它来控制重复循环操作次数在位移操作是，CL寄存器用来保存位移次数

DX寄存器称为数据(Data)寄存器，在进行32位乘除法操作时，用它存放被除数的高16位或余数。他也用于存放I/O端口地址

#### 变址寄存器和指针寄存器

==变址和指针寄存器主要用于存放某个存储单元地址的偏移，或某组存储单元开始的地址偏移，即作为存储器(短)指针使用==

SI和DI寄存器称为变址寄存器。在字符串操作中，规定由SI给出源指针，由DI给出目的指针，所以SI也称为源变址(source Index)寄存器，DI也称为目的变址(Destination Index)寄存器。当然SI和DI也可作为一般寄存器指针使用

BP和SP寄存器称为指针寄存器。BP主要用于给出堆栈中数据区基址的偏移，从而方便的实现直接读取堆栈中的数据，所以BP也称为基指针（Base Pointer）寄存器。正常情况下SP只作为堆栈指针（Stack Pointer）使用，即保存堆栈栈顶地址的偏移。堆栈是一片存储区域

### 2 段寄存器

4个段寄存器均是16位的，分别称为

代码段（Code Segment）寄存器CS，

数据（Data Segment）寄存器DS，

堆栈段（Stack Segment）寄存器SS，

附加段（Extra Segment）寄存器ES

### 3 指令指针

指令指针IP(Istrucation Pointer)也是16位的，它类似于程序计数器PC（Program Counter）。指令指针IP给出接着要执行的指令的代码段中的偏移

## 2.1.2 标志寄存器

8086/8088CPU中有一个16位的标志寄存器，包含9个标志，主要用于反映处理器状态和运行结果的某些特征。各标志寄存器中的位置如下

![image-20221128223303143](./0102%2080868088%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%92%8C%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.assets/image-20221128223303143.png)

有些指令的执行收某些标志的影响，有些指令的执行不受标志的影响。所以要充分注意指令和标志的关系。

9个标志可分为两组，第一组6个标志主要受加减运算逻辑和逻辑运算结果的影响，称为运算结果标志，第二组标志不受运算结果的运行，称为状态控制标志

### 1 运算结果标志

#### 进位标志CF（Carry Flag）

==进位标志CF主要用于反映是否产生进位或借位==。如果运算结果的==最高位产生一个进位或借位，则CF被置1，否则CF被清0==。在进行多字节的加减法运算时，要使用该标志，在比较无符号数大小事，要使用到该标志

位移指令也报错作数的最高位或最低位移入CF

#### 零标志ZF（Zero Flag）

==零标志ZF用于反映运算结果是否为0==.如果==运算结果为0，则ZF被置1，否则ZF被清0==。判断运算结果是否为0时，要使用该标志

#### 符号标志SF（Sign Flag）

==符号标志SF用于反映运算结果的符号位==。SF与运算结果的最高位相同，如果==运算结果的最高位位1，则SF被置为1，否则SF被清0==.有符号数采用补码的形式表示，所以SF反映运算结果的符号。如果运算结果为正，则SF被清0，否则SF被置1

#### 溢出标志OF（Overflow Flag）

==溢出标志OF用于反映有符号数加减运算时是否引起溢出==。如运算结果超出了8位或16位有符号数的表示范围，记载字节运算时大于127或小于-128，在子运算时大于32767或小于-32768称为溢出，如果==溢出这OF被置为1，否者OF被清0==

要特别注意，溢出标志和进位标志是两个不同心智的标志，不能混淆

#### 奇偶标志PF（Parity Flag）

==奇偶标志PF用于反映运算结果中1的个数，如果1的个数为偶数，则PF被置为1，==否则被清0.在串行通信中，我饿了提高传送的可靠性，采用奇偶校验

#### 辅助进位符AF（Auxiliary Carry Flag）

在集资额操作是，如发生低半字节向高板字节进位或借位；在字操作时，如发生低字节向高字节进位或借位，则辅助进位标志AF倍置为1，否则AF倍清0.十进制算术运算调整指令自动更具该标志产生相应的调整

### 2 状态控制标志

状态控制标志控制处理器的操作，要通过撞门的指令才能使状态控制标志发生变化

#### 方向标志DF(Direction Flag)

==方向标志决定着串操作指令执行时有关指针寄存器调整方向。==当DF为1时，串操作指令按减法方法改变有关的存储指针值；当DF为0时，串操作指令按加方式改变有关的存储器指针值。设置方向标志DF的指令是STD，专门用于清DF的指令是CLD

#### 中断允许标志IF（Interrupt-enable Flag）

==中断允许标志决定CPU是否响应外部可屏蔽中断请求。==当IF为1时，CPU能够响应外部的可屏蔽中断请求。当IF为0时，则不相应外部的可屏蔽中断请求。但此标志对外部非屏蔽中断请求，或诶不产生的中断不起作用，用于设置中断允许标志IF的指令是STI，专门用于清IF的指令是CLI

#### 追踪标志TF(Trap Flag)

==当追踪标志TF被置为1后，CPU进入单步方式==。所谓单步方式是指在一条指令执行后，产生一个单步中断。这主要用于程序调试

# 2.2 存储器分段和地址的形成

只有充分理解存储分段的概念和存储器逻辑地址和物理地址的关系，才能熟练的使用汇编语言

## 2.2.1 存储单元的地址和内容

在于8086或8088位CPU的系统中，以字节为单位线性的组织存储器。

为了标识和存取每一个存储单元，给每一个存储单元规定一个编号，也就是存储单元地址

存储单元地址用二进制数表示，从0开始，顺序地的每次加1

存储单元的地址是无符号数，n位二进制总共能表示 $2^n$个存储单元的地址，为了书写方便，存储单元地址常采用十六进制数表示

一个存储单元中存放的信息层为该存储单元的内容

图2.2示意了存储器中部分存储单元存放信息的情况

从图2.2可以看到，地址56780H字节存储单元的内容是34H,而地址为56781H的字节存储单元中的内容是12H

![image-20221129124207970](./0102%2080868088%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%92%8C%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.assets/image-20221129124207970.png)

一个字存放到存储器要占用连续两个字节单元。==系统规定，当把一个字放到存储器是，其低字节存放到地址较低的字节单元中，其高字节存放到地址较高的字节单元中。这样两个连续的字节单元就构成了一个字单元，字单元地址采用它的低地址表示==

==上述存储原则称为“高高低低”原则。在以字节方式存取字时需要特别注意该原则，当以字的方式存取字时，处理器自动采用该原则==

四个连续的字节单元就构成了一个双字单元，双字单元的地址就是最低字节单元的地址。一个双字存放到存储器时也按照“高高低低”原则存储，也即高字节在高地址中，低字节在低地址中

## 2.2.2 存储器的分段

8086/8088CPU有20根地址线，可直接寻找的物理空间为1M字节（=$2^{20}$）。系统存储器由字节为单位的存储单元组成，存储单元的物理地址长20位，范围是0000H至FFFFH。

==根据需要把1M字节地址空间划分为若干逻辑段==。每个逻辑段必须满足如下两个条件：==第一，逻辑段开始地址必须是16的倍数；第二，逻辑段的最大长度位64K，按照这两个条件，1M字节地址空间最多可划分为64K个逻辑段，最少也要划分16个逻辑段。第一个条件与段寄存器长16位有关；第二个条件与指针寄存器长16位有关==

==逻辑段与逻辑段可以相连，也可以不相连，还可以部分重叠。==

图2.3给出了若干逻辑段的划分情况。在图2.3中，段B与段C部分重叠，段E与段D相连

![image-20221129130316640](./0102%2080868088%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%92%8C%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.assets/image-20221129130316640.png)

这种存储分段方式不仅有利于实现寻址1M字节空间，而且也十分有利于对1M字节空间的管理。对实现程序的重定位和浮动，对实现代码数据的隔离，对充分利用存储空间，这种方法都有益

## 2.2.3 物理地址的形成

由于段的起始地址必须是16的倍数，所以段起始地址有如下形式：

1111 1111 1111 1111 0000

用16进制可以表示成XXXX0。这种20位的段起始地址，可压缩表示成16位的XXXX形式。==我们把20位段起始地址的高16位XXXX称为段值。显然，段起始地址等于段值乘以16（即左移4位）==

要访问的某一个存储单元总是属于某个段，我们把存储单元的地址与在段的起始地址称为段内偏差。==在一个段内，通过偏移可指定要访问的存储单元，或者是要访问的存储单元由偏移来指定。在整个1M地址空间中，存储单元物理地址等于段起始地址加上偏移==

于是，==存储单元的逻辑地址由段值和偏移两部分组成==，用如下表示：

==段值:偏移==

==根据逻辑地址可方便的得到存储单元的物理地址，计算公式如下：==

==物理地址 = 段值 * 16 + 偏移==

通过位移和算数加可以容易得实现上述公式，图2.4是物理地址产生的示意图。例如，==用16进制表示逻辑地址1234:3456H对应存储单元的物理地址为15796H==

由于段可以重叠，所以一个物理地址可用多个逻辑地址表示。图2.5是这样一个例子，其中储存单元的物理地址是12345H，标出两个重叠段的段值分别是1002H和1234H，在对应段内的偏移分别是2325H和0015H

![image-20221129132031931](./0102%2080868088%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%92%8C%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.assets/image-20221129132031931.png)

==采用段值和偏移构成逻辑地址后，段值由寄存器给出，偏移可有指令指针IP、堆栈指针SP和其他可作为存储器指针使用的寄存器（SI、DI、BX和BP）给出，偏移还可以直接用16位数给出。指令中不使用物理地址，而是使用逻辑地址，由总线接口BIU按需要根据段值和偏移自动形成20位物理地址==

==段值就是了逻辑上将物理地址分为多少段，一块物理内存的地址就是：段值 \* 16 + 偏移==

## 2.2.4 段寄存器的引用

由于8086/8088CPU==有四个段寄存器，可以保存4个段值，所以可同时使用4个段，单着四个段有所分工每当需要产生一个20位的物理地址时，BIU会自动引用一个段寄存器，且左移4位再与一个16位的偏移相加==。图2.6给出了一个同时使用四个段的例子

==在取指令的时候，自动引用代码段寄存器CS，再加上由IP所给出的16位偏移，得到要取指令的物理地址==

![image-20221129215749234](./0102%2080868088%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%92%8C%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.assets/image-20221129215749234.png)

==当涉及一个堆栈操作时，则自动引用堆栈段寄存器SS，再加上由SP所给出的的16位偏移，得到堆栈操作所需的物理地址==。==当偏移涉及BP寄存器时，缺省引用的段寄存器也为堆栈段寄存器SS==

==在存取一个普通存储器操作数时，则自动选择数据段寄存器DS或附加段寄存器ES,再加上16位偏移，得到存储器操作数的物理地址==。此时的16位偏移，可以是包含在指令中的直接地址，也可以是某一个16位存储器指针寄存器的值，也可以是指令中的偏移再加上存储器指针寄存器中的值，这取决于指令的寻址方式。==除了串操作时目的段选择附加段寄存器ES外，缺省选择数据段寄存器DS==。

==在不改变段寄存器值的情况下，寻址的最大范围是64K字节。若某个程序使用的总的存储长度（包括代码、堆栈和数据区）不超过64K字节，则整个程序可以合用一个64K字节的段==。==若有一个程序，它的代码长度、堆栈长度和数据区长度均不超过64K字节，则可在程序开始时分别给DS和SS等段寄存器赋值，在程序的其他地方就可不再考虑这些段寄存器所含的段值，程序就能正常地运行==。假如某个程序的数据区长度超过64K字节，那么就要在两个或多个数据段中存取数据。如果出现这种情况，只要在从存取一个数据段改变到存取另一个数据段时，改变数据段寄存器内的段值就可以了。

由于BIU能根据需要自动选择段寄存器，所以==通常情况下在指令中不指明所需要的段寄存器==。==取指令和堆栈操作所引用的段寄存器分别规定为CS和SS，是不可变的==：==串操作中目的段的段寄存器规定为ES也是不可变的==。但是==，在存取一般存储器操作数时、段寄存器可以不一定是DS;当偏移涉及BP寄存器时，段寄存器也不是非要为SS==。==8086/8088允许使用段超越前缀，改变上述两种情况下所使用的段寄存器，也即用段超越前缀直接明确指定引用的段寄存器。==表2.2列出了段寄存器的引用规定，其中“可选用的段寄存器”栏就列出了可作为段超越前缀改变的段寄存器，另外，有效地址EA(Effective Address）就是指段内偏移。

![image-20221129220554226](./0102%2080868088%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%92%8C%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.assets/image-20221129220554226.png)

有效地址EA（Effective Address）就是指段内偏移

# 2.3 8086/8088的寻址方式

表示指令中操作数所在的方法称为寻址方法。8086/8088有其中基本的寻址方式：==立即寻址，寄存器寻址，直接寻址，寄存器间接寻址，寄存器相对寻址，基址加变址寻址，相对基址加变址寻址==

==直接寻址、寄存器间接寻址、寄存器相对寻址、基址加变址寻址和相对基址加变址寻址，这五种寻址方式属于寄存器寻址==，用于说明操作数所在存储单元地址。由于总线接口单元BIU能根据需要自动引用段寄存器得到段值，所以这五种方式也就是确定存放操作数的存储单元有效地址EA的方法。有效地址EA是一个16位的无符号数，在利用这五种方法计算有效地址时，所得到的结果任务是一个无符号数

除了这些基本的寻址方式外，还有固定寻址和I/O端口寻址

## 2.3.1 立即寻址方式

==操作数就包含在指令中，他作为指令的一部分，跟在操作码后存放在代码段。这种操作数称为立即数==

立即数可以为8位，也可以为16位。如果立即数是16位，就按照“高高低低”原则存放

指令“==MOV AX , 1234H==”的存储和执行情况如图2.7所示。

==这种寻址方式主要用于给寄存器或存储单元赋初值的场合==

![image-20221129221818712](./0102%2080868088%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%92%8C%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.assets/image-20221129221818712.png)

## 2.3.2 寄存器寻址方法

操作数在CPU内部的寄存器中，指令中指定寄存器号。对于16位操作数，寄存器可以是AX，BX，CX，DX，SI，DI，SP和BP等；对于8位操作数，寄存器可以是AL，AH，BL，BH，CL，CH，DL，DH

例如，==指令“MOV SI，AX”和指令“MOV AL，DH”中的源操作数和目的操作数均是寄存器寻址==。再如，图2.7所示指令中，目的操作数采用寄存器寻址

由于操作数在寄存器中，不需要通过访问存储器来取得操作数，所以采用这种寻址方式的指令执行速度较快

## 2.3.3 直接寻址方式

==操作数在存储器中，指令直接包含操作数的有效地址==。操作数一般存放在数据段，所以操作数的地址由DS加上指令中直接给出的16位偏移得到。如果采用段超越前缀则操作数也可含在数据段外的其他段中

设数据段寄存器DS的内容是5000H，地址为51234H子存储单元中的内容是6789H，那么在执行==指令“MOV AX，[1234H]”后寄存器AX的内容是6789H。==图2.8是此指令的存储和执行情况。为方便，本章常用（reg）表示寄存器reg的内容，于是该例的假设用（DS）=5000H表示，执行结果用（AX）=6789H。

![image-20221129223937527](./0102%2080868088%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%92%8C%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.assets/image-20221129223937527.png)

下面指令中目标操作数采用直接寻址，==并且使用了段超越前缀：==

==MOV ES:[5678H],BL ; 引用的段寄存器是ES==

==直接寻址就是直接指定地址，ES寄存器的5678H的地址==

==段超越前缀就是指定寄存器==

这种寻址方式常用于处理单个存储器的情况。它可以实现64K字节的段内寻找操作数。==直接寻址的操作数通常是程序使用的变量==

注意立即寻址和直接寻址书写表示方法上的不同，==直接寻址的地址要放在方括号中==。在源程序中，往往用变量名表示

## 2.3.4 寄存器间接寻址方式

==操作数在存储器中，操作数有效地址在SI，DI，BX，BP这四个寄存器之一中==。==在一般情况(即不使用段超越前缀明确指定段寄存器)下，如果有效地址在SI，DI和BX中，则以DS段寄存器的内容为段值；如果有效地址在BP中，则以SS寄存器的内容为段值==

==例如：MOV AX, [SI]==

==假设：(DS) = 5000H,(SI)=1234H==

那么，存取的物理存储地址单元地址是51234H。再假设该字段存储单元内容是6789H，那么在执该指令后，(AX)=6789H，那么在执行该指令后，(AX)=6789H。图2.9反映该指令的存储和执行情况。

![image-20221129225827787](./0102%2080868088%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%92%8C%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.assets/image-20221129225827787.png)

下面指令中源操作数采用寄存器间接寻址，并且使用了段超越前缀：

```assembly
MOV DL,CS:[BX];引用的段寄存器是CS
```

下面指令中目的操作数采用寄存器间接寻址，由于使用BP作为指针寄存器，所以缺省的段寄存器是SS:

```assembly
MOV [BP],CX;引用的段寄存器是BP
```

这种寻址方式可以用于表格处理，在处理完表中的一项后，只要修改指针寄存器的内容就可以方便的处理表中的另一项

请注意书写表示寄存器间接寻址是，寄存器名一定要放在方括号中。下面两条指令的目的操作数的寻址方式完全不同

```assembly
MOV [SI],AX; 	目的操作数寄存器间接寻址
MOV SI,AX; 		目的操作数寄存器寻址
```

## 2.3.5 寄存器相对寻址方式

==操作数在存储器中，操作数的有效地址是一个基址寄存器（BX、BP）或变址寄存器（SI、DI）内容加上指令中给定的8位或16位唯一量之和==即：
$$
EA = \left\{
\begin{matrix}
(BX)\\
(BP) \\
(SI)\\
(DI)
\end{matrix}
\right\}
+
\left\{
\begin{matrix}
8位偏移量\\
16位偏移量
\end{matrix}
\right\}
$$





在一般情况下(即不使用段超越前缀明确指定段寄存器)下，如果SI、DI或BX的内容作为有效地址的一部分，那么应用的段寄存器是DS；如果BP的内容作为有效地址的一部分，那么引用的段寄存器是SS。

在指令中给点的8位或16位位移量采用补码形式表示。在计算有效地址时，如位移量是8位，则被带符号扩展成16位。==当所得的有效地址超过FFFFH，则取其64K的模==。

```assembly
假如 		MOV AX,[DI+1223H]
假设 		(DS)=5000H,(DI)=3678H
```

那么，存取的物理存储单元地址是5489BH。再设该字存储单元的内容是55AAH，那么在执行该指令后，(AX)=55AAH.图2.10反映该指令的存储和执行情况

![image-20221202133236241](./0102%2080868088%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%92%8C%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.assets/image-20221202133236241.png)

下面指令中，源操作数采用寄存器相对寻址，引用的段寄存器是SS：

```assembly
MOV BX,[BP-4]
```

下面指令中，目的操作数采用寄存器相对寻址，引用的段寄存器是ES：

```assembly
MOV ES:[BX+5],AL
```

==这种寻址方式同样可用于表格处理，表格的首地址可设置为指令中的位移量，利用修改基址或变址寄存器的内容来存取表格中的项值。==所以，这种方式很有利于高级语言中对结构或记录数据类型所实施的操作

请注意书写时基址或变址寄存器名一定要放在方括号中，而位移可不写在方括号中。下面两条指令源操作数的寻址方式是相同的，表示的形式等价：

> ==MOV AX,[SI+3]==
> ==MOV AX,3[SI]==

## 2.3.6 基址加变址寻址方式

==操作数在存储器中，操作数的有效地址由基址寄存器之一的内容与变址寄存器之一的内容相加得到。==即：
$$
EA = \left\{
\begin{matrix}
(BX)\\
(BP)
\end{matrix}
\right\}
+
\left\{
\begin{matrix}
(SI)\\
(DI)
\end{matrix}
\right\}
$$
在一般情况(即不使用段超越前缀明确指定段寄存器)下,如果BP的内容作为有效地址的一部分，则以SS的内容为段值，否则以DS的内容为段值

当所得的有效地址超过FFFFH时，就取其64K的模

```assembly
例如 	MOV AX,[BX+DI]
假设 	(DS)=5000H,(BX)=1223H,(DI)=54H
```

那么，存取的物理存储单元地址是51277H。再设该字存储单元的内容是168H，那么在执行该指令收，(AX)=168H.图2.11反映该指令的执行情况

![image-20221202160203425](./0102%2080868088%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%92%8C%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.assets/image-20221202160203425.png)

下面指令中，源操作数采用基址加变址寻址，通过增加段超前前缀引用段寄存器ES：

```assembly
MOV AX,ES:[BX+SI]
```

下面指令中，目的操作数采用基址加变址寻址，引用的段寄存器是DS:

```assembly
MOV DS:[BP+SI],AL
```

==这种寻址方式适用于数组或表格处理。用基址寄存器存放数组首地址，用变址寄存器来定位数组中各元素，或反之。由于两个寄存器都可改变，所以能更加灵活的访问数组或表格中的元素==

下面两种表示方式是等价的：

> ==MOV AX,[BX+DI]==
> ==MOV AX,\[BI][BX]==

## 2.3.7 相对基址加变址寻址方式

==操作数在存储器中，操作数的有效地址由基址寄存器之一的内容与变址寄存器之一的内容及指令中给定的8位或16位位移量相加得到==，即
$$
EA = \left\{
\begin{matrix}
(BX)\\
(BP)
\end{matrix}
\right\}
+
\left\{
\begin{matrix}
(SI)\\
(DI)
\end{matrix}
\right\}
+
\left\{
\begin{matrix}
8位位移量\\
16位位移量
\end{matrix}
\right\}
$$
在一般情况下(即不使用段超越前缀指令明确指定段寄存器)下，如果BP之内作为有效地址的一部分，则以SS段寄存器的内容作为段值，否则DS段寄存器的内容为段值

在指令中给定8位或16位位移量采用补码形式表示。在计算有效地址时，如果位移量是8位，那么被带符号扩展成16位。==当所得的有效地址超过FFFFH时，就取其64K的模。==

```assembly
例如: MOV 	AX,[BX+DI-2]
假设: (DS)=5000H,(BX)=1223H,(DI)=54H
```

那么存起的物理存储单元地址是51275H。再设该字存储单元的内容是7654H,那么在执行该指令后，(AX)=7654H。图2.12反映该指令的存储和执行情况，位移用补码表示

![image-20221202162200129](./0102%2080868088%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%92%8C%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.assets/image-20221202162200129.png)

==尽管相对基址加变址寻址这种寻址方式最为复杂，但也是最灵活。==

==相对基址加变址寻址这种寻址方式的表示方法多种多样，下面四种表示方法均是等价的：==

> ==MOV		AX,[BX+DI+1234H]==
> ==MOV 	AX,1234H[BX+DI]==
> ==MOV 	AX,1234H\[BX][DI]==
> ==MOV 	AX,1234H\[DI][BX]==

# 2.4 8086/8088指令系统

本节详细介绍8086\8088指令集中的大部分常用逻辑，剩下的部分指令分散在有关的章节中介绍

## 2.4.1 指令集说明

### 1.分组

与早先的8位微处理器相比，8086/8088的指令系统相当丰富，而且指令功能也强大。大多数指令既能处理字数据，又能处理字节数据；算术运算和逻辑运算不局限于累加器，存储器操作数也可以直接参加算数逻辑运算

8086/8088的指令系统课分为如下六个功能组

- 数据传送
- 算术运算
- 逻辑运算
- 串操作
- 程序控制
- 处理器控制

### 2.指令表示格式

为了方便的极少指令系统中的指令，我们先介绍汇百年语言中指令语句的一般格式。在汇编语言中，指令语句可由四部分组成，一般格式如下：

> ==[标号·] 	指令助记符 	[操作数1 	[, 操作数2]] 	[;注释]==

指令是否带有操作数，完全取决于指令本身，有的指令无操作数，有的指令只有一个操作数，有的指令需要两个操作数。标号使用取决于程序的需要，是否写上注解有程序员决定。请注意：标号纸杯汇编程序识别，他与指令本身无关；由分号引导的注释则纯粹是为了理解和方便阅读程序需要，汇编程序将其全部忽略，对不会影响指令。

### 3.其他说明

对于每一条指令，程序员要注意一下几点

1. 指令的功能
2. 适用于指令的操作数寻址方式
3. 指令对标志的影响
4. 指令的长度和执行时间

## 2.4.2 数据传送指令

数据传送指令又可分为：传送指令，交换指令，地址传送指令，堆栈操作指令，标志传送指令，查表指令，输入输出指令。查表质量和输入输出指令在有关章节介绍

除了SAHF和POPF指令外，这组指令对各个标志没有影响

### 1.传送指令

传送指令是使用的最频繁的指令，起格式如下：

```assembly
MOV	DST,SRC
```

==此指令把一个字节或以一个字从源操作数SRC送至目的操作数DST==

源操作数可以是累加器、寄存器、存储单元以及立即数，而目的操作数可以是累加器、寄存器和存储单元。==传送不改变源操作数==。

MOV 指令可实现的传送方向如图2.13所示：

![image-20221202172135507](./0102%2080868088%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%92%8C%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.assets/image-20221202172135507.png)

#### 1 CPU内部寄存器之间的数据传输。例如：

```assembly
MOV		AH,AL
MOV 	DL,BH
MOV 	BP,SP
MOV 	DS,BX
```

就寄存器之间的传输而言，下列情况是例外：

- ==源和目的不能同时是段寄存器；==
- ==代码段寄存器CS不能作为目的；==
- ==指令指针IP既不能作为原，也不能作为目的。==

注意这种例外永远存在

#### 2 立即数送至通用寄存器或存储单元(各种存储器寻址方式)。例如：

```assembly
MOV 	AL,3
MOV 	SI,-5
MOV 	VARB,-1
MOV 	VARW,3456H
MOV 	[SI],6543H
```

==注意，立即数不能直接传送至段寄存器，立即数永远不能作为目的操作数==

#### 3 寄存器与存储器之间的数据层传输

```assembly
MOV		AX,VARW 	;VARW是一个字变量，存储器操作为直接寻址
MOV		BH,[DI]		;存储器操作数为寄存器间接寻址
MOV 	DI,ES:[SI+3];存储器操作数为相对变址寻址，使用段超越前缀
MOV		BP,[BX+SI+3];存储器操作数为相对基址加变址寻址
MOV 	VARB,DL 	;VARB是一个字节变量
MOV 	[BP],AX		;使用SS段寄存器
MOV 	DS:[BP],DL	;使用段超越前缀
MOV 	VARW,DS 	;VARW是一个字变量
MOV 	ES,VARW
```

对存储器操作而言，可采用各种存储器寻址方式，这一点对其他指令也是一直成立的。关于MOV指令，除前面的例外还要遵守以下规定

1. ==原操作数和目的操作数类型要一致。即同时为字节或字，不能一个为字节，另一个为字==
2. ==除了串操作指令外，源操作数和目的操作数不能同时为存储器操作数==

==这些例外和规定不仅适用于MOV指令，也同样适用于所有涉及操作数的指令。==

如果要在两个存储单元建传送数据，那么可利用通用寄存器过度的方法进行，例如：

```assembly
MOV		AX,VARW1 	;把字变量VARW1的内容送到自变量VARW2
MOV 	VARW2,AX
```

这种利用通用寄存器过度的方法，也是用于段寄存器间的数据传送。例如：

```assembly
MOV		AX,CS 		;把CS内容传送到DS
MOV 	DS,AX 
```

### 2.交换指令 XCHG

==利用交换指令可方便地实现通用寄存器和通用寄存器或存储单元间的数据交换==，交换指令的格式如下：

```assembly
XCHG 	OPRD1,OPRD2
```

此指令把操作数OPRD1的内容与操作数OPRD2的内容交换。操作数同时是字节或字，例如：

```assembly
XCHG 	AL,AH
XCHG 	SI,BX
```

==OPRD1和OPRD2可以是通用寄存器和存储单元。但不包括段寄存器，也不能同时是存储单元，还不能是立即数，==这符合已介绍过的例外和规定，可采用各种存储器寻址方式来指定存储单元。例如：

```assembly
XCHG	[SI+3],AL
XCHG 	[DI+BP+3],BX
```

### 3.地址传送指令

8086/8088有如下三条地址传送指令

LEA/LDS/LES

#### 1 指令 LEA

==传送地址指针的指令==

==指令LEA称为传送有效地址指令==，其格式如下：

```assembly
LEA 	REG,OPRD
```

==该指令把操作数OPRD的有效地址传送到操作数REG。操作数必须是一个存储器操作数，操作数REG必须是一个16位的通用寄存器==。例如：

```assembly
LEA		AX,BUFFER 		;BUFFER是变量名
LEA 	DX,[BX+3]
LEA 	SI,[BP+DI+4]
```

请注意，==LEA指令把与存储单元中的数据传送到寄存器的MOV指令有本质上的区别==，假设变量那个BUFFER的偏移量是1234H，该字变量的值为5678H，那么执行完指令`LEA	AX,BUFFER`后，AX寄存器中的值为1234H，而不是5678H，在执行完指令`MOV AX,BUFFER`后，AX寄存器中的值为5678H，而不是1234H

==LEA与MOV的区别是==

1. ==MOV移动的变量的值==
2. ==LEA移动的是偏移量==

#### 2 指令 LDS

==传送地址指针的指令==

段值和段内偏移构成32位的地址指针。==该指令传送32位地址指针==，其格式如下：

```assembly
LOD		REG，OPRD
```

==该指令把操作数OPRD中所含的一个32位地址指针的段值部分送到数据段寄存器DS，把偏移部分送到指令给出的通用寄存器REG==。操作数OPRD必须是一个32位的存储器操作数，操作数REG可以是一个16位通用寄存器，但实际使用的往往是变址寄存器或指针寄存器，例如：

```assembly
LDS		DI,[BX]
LDS 	SI,FARPOINTER 		;FORPOINTER是一个双字变量
```

假设双字变量FARPOINTER包含32位地址指针的段值为5678H，偏移位1234H，那么在执行指令“LDS	SI,FARPONITER”后段寄存器DS的值为5678H，寄存器SI的值为1234H。32位地址指针的偏移部分存储在双字变量的低地址字中，段值部分存储在高地址中。图2.14是该指针执行示意图。

![image-20221203194826363](./0102%2080868088%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%92%8C%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.assets/image-20221203194826363.png)

==LDS移动的是变量值==

#### 3 指令 LES

LES指令也传送32位地址指针，其格式如下：

```assembly
LES 	REG,OPRD 
```

==该指令把操作OPRD中包含的32位地址指针的段值部分送到附加段寄存器ES，把偏移部分送到指令给出的通用寄存器REG==。其他指令说明同指令LDS

## 2.4.3 堆栈操作指令

在8086/8088系统中，堆栈是一段RAM区域。==称为栈底的一端地址较大，称为栈顶的一端地址较小。堆栈的段值在堆栈段寄存器SS中，堆栈指针寄存器SP始终指向栈顶。只要重新设置SS和SP的初值(例如用MOV指令)，就可以改变堆栈的位置。堆栈的深度由SP的初值决定==

堆栈操作始终遵守“后进先出”的原则，所有数据的存入和取出都在栈顶进行。在8086/8088系统中，进出堆栈的数据均为字位单位。

我们先列出堆栈的如下主要用途，每种用途的具体使用情况再以后得章节中陆续做出介绍：

1. ==现场和返回地址保护==
2. ==寄存器内容保护==
3. ==传递参数==
4. ==存储局部变量==

堆栈操作指令分为两种：进栈指令PUSH和出栈指令POP

### 1.进栈指令 PUSH

进栈指令把16位数据压入堆栈，其格式如下：

```assembly
PUSH 	SRC
```

==该指令把源操作数SRC压入堆栈。它先把堆栈指针寄存器SP的值减2，然后把源操作数SRC送入由SP所指的栈顶。==图1.25（a）和（b）示意指令“PUSH 	AX”执行前后堆栈的变化情况，假设AX=8A9BH。==随着压入堆栈的数据增多，堆栈也逐步扩展。SP值随着压栈而减小，但每次操作完，SP总指向栈顶。==当把一个16位数据压入堆栈时，总是遵守“高高低低”原则

![image-20221203200352745](./0102%2080868088%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%92%8C%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.assets/image-20221203200352745.png)

==源操作数SRC可以是通用寄存器和段寄存器，也可以是字存储单元==。例如：

```assembly
PUSH 	SI
PUSH 	DS
PUSH 	VARW 	;VARW是字变量
PUSH 	[SI]
```

### 2.出栈指令 POP

==出栈指令从堆栈弹出16位数据==，其格式如下：

```assembly
POP 	DST
```

==该指令从栈顶弹出一个字数据到目的操作数DST。它先把堆栈指针寄存器SP所指的字数据送至目的操作数DST，然后SP值加2，使其仍指向栈顶。==图2.15(b)和(c)示意执行指令“POP 	AX”前后的堆栈变化情况。==随着弹出堆栈的数据增多，堆栈也逐步收缩。SP值随着弹出操作而增大，但每次操作完，SP总指向栈顶==。

目的操作数DST可以是通用寄存器和段寄存器(但CS例外)，也可以是子存储单元。例如：

```assembly
POP 	[SI]
POP 	VARW 	;VARW是字变量
POP 	ES
POP 	SI
```

下面的程序片段说明堆栈的一种用途，临时保存寄存器的内容：

```assembly
PUSH 	DS		;保护DS
PUSH 	CS
POP 	DS		;使DS的内容与CS的内容相同
.... 			;其他操作
POP		DS		;恢复DS
```

## 2.4.4 标志操作指令

8086/8088指令集中，有一部分指令是专门对标志寄存器为标志位进行的，包括==四条标志寄存器传送指令和七条专门用于设置或清除某些标志位的指令==。

### 1.标志传送指令

标志传送指令属于数据传送指令组

#### 1 指令LAHF（Load AH with Flags）

指令LAHF采用固定寻址方式，指令格式如下：

```assembly
LAHF
```

==该条指令把标志寄存器的低8位(包括符号标志SF、零标志ZF、辅助进位标志AF、奇偶标志PF和进位标志CF)传送到寄存器AH的指令位，即相应的传送至寄存器AH的位7、6、4、2和0==，其他的位(位5、3和1)的内容无定义，如图2.16所示

![image-20221203202138894](./0102%2080868088%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%92%8C%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.assets/image-20221203202138894.png)

这条指令本身不影响这些标志和其他标志

#### 2 指令SAHF(Store AH into Flags)

指令SAHF采用固定寻址方式，其格式如下：

```assembly
SAHF
```

==该条指令与指令LAHF刚好相反，把寄存器AH的指定位送至标志寄存器低8位的SF、ZF、AF、PF和CF标志位。==因而这些标志的内容就要受到影响，并取决于AH中相应位的状态。但这条指令不影响溢出标志OF、方向标志DF、中断允许标志IF和追踪标志TF，也既不影响标志寄存器的高字节为。例如：

```assembly
MOV 	AH,0C1H
SAHF 					;CF=1,PF=0,AF=0,ZF=1,SF=1
```

#### 3 指令PUSHF

指令PUSHF的格式如下：

```assembly
PUSHF
```

==该条指令把寄存器的内容压入堆栈，即先把堆栈指针寄存器SP的值减2，然后把标志寄存器的内容送入由SP所指的栈顶==。

这条指令不影响标志。

#### 4 指令POPF

指令POPF的格式如下：

```assembly
POPF 
```

==该条指令吧当前堆栈顶的一个字传送到标志寄存器，同时相应的修改堆栈指针，即把堆栈寄存器SP的值加2==

在执行该指令后，标志寄存器各位会发生变化

==这条指令和PUSHF指令一起保存和恢复标志寄存器的内容，即保存和回复各标志的值。==另外，这两条指令也可以改变追踪标志TF。在8086/8088指令系统中，没有专门设置和清理TF标志的指令，为了改变TF标志，可以先用PUSHF指令将变址压入堆栈，然后设法改变栈顶字段元中的第8位(把整个寄存器卡成是一个字)，在用POPF指令吧该字弹回到标志寄存器中，这样其余标志不受影响，而只有TF标志按需要改变了

### 2.标志位操作指令

标志位操作指令出于处理器控制指令组，他们仅对指令规定的标志产生指令规定的影响，对其他标志没有影响

#### 1 清进位标识指令CLC（Clear Carry Flag）

清进位标志指令格式如下

```assembly
CLC
```

==该条指令使进位标志位0==

#### 2 置进位标志指令STC（Set Carry Flag）

置进位标志指令的格式如下：

```assembly
STC
```

==该条指令使进位标志位1==

#### 3 进位标志取反指令CMC(Complement Carry falg)

进位标志取反指令的格式如下：

```assembly
CMC
```

==该条指令使进位标志取反。如CF位1，则使CF位0；如CF位0，则CF位1。==

#### 4 清方向标志CLD（Clear Direction Flag）

清方向标志指令的格式如下：

```assembly
CLD
```

==该条治指令使方向标志DF为0.从而在执行串操作指令使，使地址按递增方式变化==

#### 5 置方向标志STD(Set Direction falg)

置方向标志指令的格式如下：

```assembly
STD
```

==该条指令使方向标志DF为1从而在执行串操作指令使，使地址按递减方式变化。==

#### 6 清中断标志CLI（Clear Interrupt enable Flag）

清中断标志指令的格式如下

```assembly
CLI
```

==该条指令使中断允许标志IF为0，于是CPU就不响应来自外部装置的可屏蔽中断。但对不可屏蔽的中断和内部中断都没有影响==

#### 7 置中断允许标志STI（Set Interrupt enable Flag）

置中断允许标志指令格式如下：

```assembly
STI
```

==该条指令是中断允许标志IF为1 ，则CPU可以响应可屏蔽中断==

## 2.4.5 加减运算指令

8086/8088提供加、减、乘、除四种基本算数运算操作。这些操作都可以用于字节或字的运算，也可以用于无符号数的运算或有符号数的运算。有符号数用补码表示。加减运算指令不再分为无符号数运算指令和有符号数运算指令，而乘除运算指令分为无符号数运算指令和有符号数运算指令。另外，8086/8088还提供各种十进制算数运算调整指令

关于加减运算指令，有如下几点通用说明，需要注意：

1. 加减运算对无符号数和有符号数的处理一视同仁。即作为无符号数而影响标志CF和AF，也作为有符号数影响标志OF和SF，当然总会影响标志ZF。加减运算指令也要影响标志PF。有些指令稍有例外
2. 可参与加减运算的操作数如图2.17所示。总是只有通过寄存器或存储单元可用于存放运算结果。如果参与运算的操作数有两个，则醉倒只能有一个是存储器操作数
3. 如果参与运算的操作数有两个，则它们的类型必须一致，即同为字节，或同时为字
4. 存储器操作数可采用2.3节中介绍的四种存储器操作数寻址方式

![image-20221205102043059](./0102%2080868088%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%92%8C%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.assets/image-20221205102043059.png)

### 1.加法指令

#### 1 普通加法指令 ADD

普通加法指令的格式如下：

```assembly
ADD 	OPRD1,OPRD2 
```

这条指令完成两个操作数相加，结果送至目的操作数OPRD1，即

> OPRD1<=OPRD1 + OPRD1

例如：

```assembly
ADD 	AL,5
ADD 	AL,AH
ADD 	DI,DI
ADD 	BL,VARB 	;VARB是字节变量
ADD 	VARW,SI 	;VARW是字变量
ADD		[BX+SI-3],AX
```

我们用下面的程序片段说明加法指令对其标志的影响，同事说明这8位寄存器与16位寄存器间的关系，为了方便说明，采用16进制的形式表示数据

```assembly
MOV 	AX,7896H 	;AX=7896H,即AH=78H,AL=96H
					;各标志位保持不变
ADD 	AL,AH 		;AL=0EH,AH=78H,即AX=780EH
					;CF=1,ZF=0,SF=0,OF=0,AF=0,PF=0
ADD		AH,AL 		;AH=86H,AL=0EH,即AX=860EH
					;CF=0,ZF=0,SF=1,OF=1,AF=1,PF=0
ADD 	AL,OF2H 	;AL=00H,AH=86H,即AX=8600H
					;CF=1,ZF=1,SF=0,OF=0,AF=1,PF=1
ADD 	AX,1234H 	;AX=9834H,即AH=98,AL=34H
					;CF=0,ZF=0,SF=1,OF=0,AF=0,PF=0
```

#### 2 带进位加指令ADC

带进位加指令的格式如下：

```assembly
ADC 	OPRD1,OPRD2
```

这条指令与ADD指令类似，完成两个操作数相加，但还要把标志位CF的现行值加上去，把结果送至目的操作数OPRD1，即：

> OPRD1<=OPRD1 + OPRD2

例如：

```assembly
ADC 	AL,[SI]
ADC 	DX,AX
ADC 	DX,VARW 	;VARW是字变量
```

ADC指令主要用于多字节运算中。尽管8086/8088中可以进行16位运算，但16位二进制数能够表达的整数范围还是很有限的，为了扩大数的范围，仍需要多字节运算。例如，有两个四字节的数相加，加法要分两次进行，先进行低两字节相加，然后在做高两字节相加。在高两字节相加时，要把低两字节相加以后可能出现的进位考虑进去，用ADC指令实现这点很方便

下面的程序片段实现两个四字节数相加，注意传送指令不影响标志：

```assembly
MOV 	AX,FIRST1 	;FIRST1是存放第一个数低两字节的变量
ADD 	AX,SECOND 	;SECOND是存放第二个数低两字节的变量
MOV 	THRED1,AX 	;保存低两字节相加的结果到THIED1变量中
MOV 	AX,FIRST2 	;FIRST2是存放第一个数高两字节的变量
ADC 	AX,SECOND2 	;SECOND2是存放第二个数高两字节的变量
MOV 	THIRD2,AX 	;保存结果到高两字节THIRD2变量中
```

#### 3 加1指令INC

加1指令的格式如下：

```assembly
INC 	OPRD
```

这条指令完成对操作数OPRD加1，然后吧结果送回OPRD,即：

> OPRD <= OPRD + 1

例如：

```assembly
INC 	AL
INC 	VARB 	;VARB是字字节变量
```

### 2.减法指令

#### 1 普通减法指令SUB

普通剪发指令格式如下：

```assembly
SUB 	OPRD1,OPRD2
```

这条指令完成两个操作数相减，从OPRD1中减去OPRD2,结果送到目标操作数OPRD1中，即：

> OPRD1<=OPRD1-OPRD2

例如：

```assembly
SUB 	AH,12
SUN 	BX,BP
SUB 	AL,[BX]
SUB 	BX,VARW 	;VARW是字变量
SUB		[BP-2],AX
```

我们用下面的程序片段说明减法指令对其标志的影响，同事再次说明8位寄存器与16位数据寄存器间的关系。安排注释用于说明对应指令治理指令完受影响的寄存器和标志位的变化，为了方便说明，还采用16进制的形式表示数据

```assembly
MOV 	BXm9045H 	;BX=9084H,即BH=90H,BL=48H
SUB 	BH,BL		;BH=48H,BL=48H,即BX=4848H
					;CF=0,ZF=0,SF=0,OF=1,AF=1,PF=1
SUB 	BL,BH 		;BL=00H,BH=48H,即BX=4800H
					;CF=0,ZF=1,SF=0,OF=0,AF=0,PF=1
SUB 	BL,5 		;BL=FBH,BH=48H,即BX=48FBH
					;CF=1,ZF=0,SF=1,OF=0,AF=1,PF=0
SUB 	BX,8F34H 	;BX=B9C7H，即BH=89H,BL=C7H
					;CF=1,ZF=0,SF=1,OF=1,AF=0,PF=0
```

#### 2 带进（借）位的减法指令SBB

带借位指令的格式如下：

```assembly
SBB		OPRD1,OPRD2
```

这条指令与SUB指令雷士，在操作数OPRD1减去操作数OPRD2的同事还要减借位标志CF的现行值，即：

> OPRD1<=OPRD1 - OPRD2 - CF

例如：

```assembly
SBB 	AL,DL
SBB 	DX,AX
```

该指令主要用于多字节数相减的场合

#### 3 减1指令DEC

减1指令DEC的格式如下：

```assembly
DEC 	OPRD
```

这条指令把操作数OPRD减1，并把结果送回OPRD，即：

> OPRD <= OPRD -1

例如：

```assembly
DEC 	BX
DEC 	VARB 	;VARB是字节变量
```

==操作数OPRD可以是通用寄存器，也可以是存储单元。==在相减时，把操作数作为一个无符号数对待，这条指令的结果影响标志ZF、SF/OF/PF/AF，但它不影响CF

该条指令主要用于调整地址指针和计数器

#### 4 取补指令NEG

取补指令格式如下：

```assembly
NEG 	OPRD 
```

这条指令对操作数取补，就是用0减去操作数OPRD，再把结果送回OPRD，即：

> OPRD<=0-OPRD

例如：

```assembly
NEG 	AL
NEG 	VARW[SI] 	;有效的地址是变量varw的唯一加SI的值
```

如在字节操作时对-128取补，或在字操作是对-32768取补，则操作数没有变化，但OF被置位。操作数可以是通用寄存器也可以是存储单元。此指令的执行结果影响CF/ZF/SF/OF/AF/PF，一般总时CF为1，除非操作时为0

#### 5 比较指令CMP

比较指令格式如下：

```assembly
CMP 	OPRD1,OPRD2
```

==这条指令完成操作数OPRD1减去操作数OPRD2，结果不送到OPRD1，但影响标志CF/ZF/SF/OF/AF/PF==。例如：

```assembly
CMP		SI,DI
CMP 	CL,5
CMP		DX,[BP-4]
```

==比较指令主要用于比较两个数的关系 ，是否相等，谁大谁小，在执行了比较指令后，可以根据ZF是否置位，判断两者是否相等，如果两者是无符号数，则可根据CF判断大小；如果两者是有符号数，则要根据SF和OF判断的大小==

例，设有两个64位数按”高高低低“原则存放在同一段的两个换从去DATA1和DATA2中，现需要计算DATA1-DATA2.下面的程序片段计算DATA1-DATA2，结果放在DATA1中，可能发生的错误保存在CF中：

```assembly
		....
		MOV 	CX,4		;64为分成4个字
		SUB 	BX,BX		;清指针
NEXT: 	MOV 	AX,DATA2[BX];取减数
		SBB 	DATA1[BX],AX;带借位减
		INC 	BX 			;调整指针
		INC 	BX			;
		DEC 	CX 			;是否已处理完4个字
		JNZ 	NEXT 		;没完，继续
		...
```

## 2.4.6 乘除运算指令

8086/8088除了提供加减运算指令外，还提供乘除运算指令乘除运算质量分为无符号运算指令和有符号运算指令，这点与加减运算指令不同。乘除运算指令对吧标志位的影响有些特别，不像加减运算指令对标志位的影响那样自然

### 1.乘法指令

在乘法指令中，一个操作数总是隐含在寄存器AL中（8位数相乘）或者AX中（16位数相乘），另一个操作数可以采用除立即数方式以外的任意一种方式寻址

#### 1 无符号数乘法指令MUL

无符号数乘法指令如下：

```assembly
MUI OPRD 
```

==如果OPRD是字节操作数，则把AL中的无符号数与OPRD相乘，16位结果送到AX中，如果把OPRD是字操作数，则把AX中的无符号数与OPRD相乘==，32位结果送到DX和AX中，DX含高16位，AX含第16位。所以由操作数OPRD决定是字节相乘还是字相乘。例如：

```assembly
MUL 	BL 
MUL 	AX 
MUL 	VARW 		;VARW是字变量
```

==如果乘积结果的高半部分（字节相乘是位AX，在字相乘时为DX）不等于零，则标志CF=1,OF=1;否则CF=0,OF=0==。所以如果CF=1和OF=1表示在AX活DX中含有结果的有效数。该指令对其他标志位无定义。

#### 2 有符号数乘法指令IMUL

有符号好书乘法指令格式如下：

```assembly
IMUL 	OPRD 
```

这条指令吧乘数和乘数均作为有符号数，此外与指令MUL完全相识。例如：

```assembly
IMUL 	CL
IMUL 	DX 
IMUL 	VARW 		;VARW是字变量
```

==如果乘积结果的高半部分（字节相乘为AX，在字相乘时为DX）不是低半部分的符号扩展，则标志CF=1,OF=1；否则CF=0,OF=0,所以如果CF=1和OF=1表示在AH或DX中含有结果的有效数==。该指令对其他标志位无定义

### 2.除法指令

在除法指令中，被除数总是在隐含在寄存器AX(除数是8位)或者DC和AX（除数是16位）中，另一种操作数可以采用除立即数放室外的任意一种寻址方式。

#### 1 无符号数除法指令DIV

无符号数除法指令的格式如下：

```assembly
DIV 	OPRD 
```

如果OPRD是字节操作数，则把AX中的无符号数除以OPRD，==8位的商送到AL中==，8位的余数送到AH中录入过OPRD是自操作，则把DX（高16位）和AX中的无符号数除以OPRD，==16位的商送到AX，16位的余数送到DX==中，所以由操作数OPRD决定是字节除还是字除。例如：

```assembly
DIV 	BL
DIV 	SI
DIV 	VARW 		;VARW是字变量
```

注意：如果除数是0，或者在8位数除是商超过8位，或者在16位除是商超过16位，则认为是除溢出，引起0中断

除法指令对标志位的影响无定义

#### 2 有符号数除法指令IDIV

有符号数除法指令的格式如下：

```assembly
IDIV 	OPRD 
```

这条指令把被除数和除数均作为有符号数，此外与指令完全类似

例如：

```assembly
IDIV 	CX
IDIV 	VARW 		;VARW是字变量
```

当除数为0时，或者商太大(字节除是超过127，字除是超过32767),或者商太小（字节除时小于-127，字除是小于-32767）,则引起零中断

### 3.符号扩展指令

由于除法指令隐含使用字被除数或双字被除数，所以当被除数为字节，或者除数和被除数均为字时，需要在除操作前扩展被除数，为此8086/8088专门提供了符号扩展指令

#### 1 字节转换为字指令CBW

字节转换为字指令的格式如下：

```assembly
CBW 
```

这条指令把寄存器AL中的符号扩展到寄存器AH。即AL的最高有效位0，则AH=0；若AL的最高有效位为1时，这AH=0FFH。例如：

```assembly
MOV 	AX,3487H 		;AX=3487H,即AH=34H,AL=87H
CBW 					;AH=0FFH,AL=87H,即AX=0FF87H
```

这个指令能在两个字节想出以前，产生一个字长度的被除数。这条指令不影响各标志位

#### 2 字转换为双字指令CWD

字转换为双字指令格式如下：

```assembly
CWD
```

这条指令吧寄存器AX中的符号扩展到寄存器DX。即若（AX）的最高有效位为0，则DX=0；若AX的最高有效位为1，则DX=0FFFFH

例如：

```assembly
MOV 	AX,4567H 		;AX=4567H
CWD						;AX=4567H,DX=0
```

这条指令能在两个字相除以前产生一个双字长度的被除数。该指令不影响各标志位

注意：在无符号数除之前，并不已使用CBW或CWD指令扩展符号位，一般采用XOR指令清高8位或高16位

例如，计算如下表达式的值：
$$
(X * Y + Z - 1024)/75
$$
假设其中xyz均为16位带符号数，分别存储在名为XXX/YYY/ZZZ变量单元中。在假设计算结果的商保存在AX中，余数保存在DX中。下面程序能够满足要求

```assembly
...
MOV 	AX,XXX			
IMUL 	YYY					;计算x*y
MOV 	CX,AX
MOV 	BX,DX				;积保存到BX，CX中
MOV 	AX,ZZZ
CWD							;把zzz扩展成32位
ADD 	AX,CX				;再计算和
ADC	 	DX,BX
SUB 	AX,1024 			;在计算差
SBB		DX,0
MOV 	CX,75
IDIV 	CX 					;最后计算商和余数
...
```

## 2.4.7逻辑运算与位运算指令

这组指令包含逻辑运算、位移和循环位移指令三部分。逻辑运算指令除指令NOT外，均有两个操作数，位移和循环位移指令只有一盒操作数。关于这组指令有如下几点通用说明，请于注意

1. 如果指令又两个操作数，那么这两个操作数也可如图2.17所示结合。但最多只能有一个为存储器操作数
2. 只有通用寄存器或存储器操作数可作为目的操作数，用于存放运算结果
3. 如果只有一个操作数，则这个操作数即是源又是目的
4. 操作数可以是字节也可以为字，但如果有两个操作数，则它们的类型必须一致，即同时为字节或者同时为字
5. 对于存储器操作数可采用2.3节中介绍的四种存储器操作数寻址方式

### 1.逻辑运算指令

#### 1 否操作指令

否操作指令的格式如下：

```assembly
NOT 	OPRD
```

这条指令吧操作数OPRD取反，然后送回OPRD

例如

```assembly
NOT 	AX
NOT 	VARB 		;VARB是字节变量
```

操作数OPRD可以是通用寄存器，也可以是存储器操作数。此指令对标志没有影响

#### 2 与操作指令AND

与操作指令的格式如下：

```assembly
AND 	OPRD1,OPRD2
```

==这条指令对两个操作数进行按位的逻辑”与“运算，结果送到OPRD1==

例如：

```assembly
ADN 	DH,DH
AND 	AX,ES:[SI]
```

==两位均为1时，结果才为1，否则为0==

==该指令执行后，标志CF=0,标志OF=0==，标志PF/ZF/SF反映运算结果，标志AF未定义

某个操作数自己与自己”与“，则值不变，但可使进位标志CF清0.==与操作指令主要用在使某一个操作数中的若干位维持不变，而另一个若干位清零的场合，把要维持不变的这些位于”1“相”与“，而把要清位0的这些与”0“相”与“就能达到目的==

例如：

```assembly
MOV 	AL,34H		;AL=34H
AND 	AL,0FH		;AL=04H
```

#### 3 或操作指令OR

或操作指令的格式如下：

```assembly
OR 		OPRD1,OPRD2
```

==两位均为0时，结果才为0，否则为1==

==这条指令对两个操作数进行安慰的逻辑”或“运算，结果送到目的操作数OPRD1==

例如：

```assembly
OR 		AX,8080H
OR 		CL,AL
OR		[BX-3],AX
```

OR 指令执行后，标志CF=0,标志OF=0,标志PF/ZF/SF反映运算结果，标志AF未定义

某个操作数自己与自己相”或“，则值不变，但可使进位标志CF清0.==或操作指令主要用在是一个操作数中的若干位维持不变，而另外若干位置为1的场合。把要维持不变的这些位于”0“相“或”，而把要置为1的这些位于”1“相”或“就能打到这样的目的==

例如：

```assembly
MOV 	AL,41H		;AL=010000001B,b表示二进制
OR 		AL,20H		;AL=01100001B
```

#### 4 异或操作指令XOR

```assembly
XOR 	OPRD1,OPRD2
```

两位不同时，结果才为1，否则为0

==这条指令对两个操作数进行按位的逻辑“或”运算，结果送到目的操作数OPRD1。==

#### 5 测试指令test 

```assembly
TEST OPRD1,OPRD2
```

和按位”与“类似，但不赋值

### 2.一般位移指令

```assembly
SAL 	OPRD,M;算数左移
SHK		ORRD,M;逻辑左移
SAR		OPRD,M;算数右移
SHR		OPRD,M;逻辑右移
```

m是位移数，1或CL，要位移多位时，需存放在CL寄存器上

标志PF\SF\ZF反映位移后的结果

#### 1 算数左移和逻辑左移

```assembly
SAL 	OPRD,M
SHL 	OPRD,M
```

==把操作数OPRD左移m位，右边补0，移出的最高位进入标志位CF==

如图2.18所示

![image-20221205180819926](./0102%2080868088%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%92%8C%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.assets/image-20221205180819926.png)

下面程序片段用于说明指令对标志位的影响

```assembly
MOV 	AL,8CH			;AL=8CH
SHL 	AX,1 			;AL=18H,CF=1,PF=1,ZF=0,SF=0.OF=1
MOV 	CL,6			;CL=6
SHL 	AL,CL 			;AL=0,CF=0,PF=1,ZF=1,SF=0,OF=0
```

下面程序片段实现AL中内容乘10，结果放入到AX中：

```assembly
XOR 	AH,AH 		;AH=0
SHL 	AH,1 		;2X
MOV		BX,AX 		;暂存2x
SHL 	AX,1 		;8X
ADD 	AX,BX 		;8X+2X
```

算数左移相当于乘以2

#### 2 算数右移 SAR

```assembly
SAR 	OPRD,M
```

==将操作数右移m位，符号位不变，移出的最低位进入标志位CF== 

```assembly
SAR 	AL,1
SAR		BX,CL
```

算数右移相当于除以2

#### 3 逻辑右移 SHR

```assembly
SHR 	OPRD,M
```

==使操作数右移m位，左边用0补，移出的最低位进入标志位CF==

```assembly
SHR 	BL,1
SHR 	AX,CL
```

对于无符号数而言，逻辑右移一位相当于除以2

在汇编语言中，经常需要对以位为单位的数据进行合并和分解处理。一般通过位移指令和逻辑运算指令进行各种数据的合并和分解处理

例：DATA1和DATA2个长4位，分别存放在AL寄存器的低4位和高4位中，现在要把他们分别存放到BL寄存器和BH寄存器的低4位中

```assembly
....
MOV 	BL,AL
AND 	BL,0FH		;的DATA1
MOV 	BH,AL 		;得DATA2
MOV 	CL,4
SHR 	BH,CL
....
```

### 3.循环位移指令

8086/8088有四条循环移位指令：==左循环移位指令ROL(ROtate L.eft),右循环移位 指令ROR(ROtate Right）,带进位左循环移位指令RCL(Rotate Left throughCF),带进 位右循环移位指令RCR(Rotate Right through CF)。这些指令可以一次只移一位，也可 以一次移多位。如移多位，那么移位次数存放在CL.寄存器中。== 

这些指令的格式如下：

```assembly
POL 	OPRD,m
ROR 	OPRD,m
RCL 	OPRD,m
RCR 	OPRD,m
```

其中,m是移位次数，或为1或为CL.操作数OPRD可以是通用寄存器,也可以是存 储器操作数。 前两条循环指令没有把进位标志位CF包含在循环的环中；

后两条循环指令把进位标志CF包含在循环的环中，即作为整个循环的一部分。四条循环指令的操作如图2.19 所示。

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20221207/image.4yzp4d17e9s0.webp)

==这些指令只影响标志CF和OF==。 

==左循环移位指令ROL,它每移位一次，操作数左移，其最高位移人最低位，同时最高 位也移入进位标志CF。==

==右循环移位指令ROR,它每移位一次，操作数右移,其最低位移入最高位，同时最低 位也移入进位标志CF。== 

==带进位左循环移位指令RCL,它每移位一次，操作数左移，其最高位移入进位标志 CF,CF移入最低位。== 

==带进位右循环移位指令RCR,它每移位一次，操作数右移.其最低位移入进位标志 CF.CF移入最高位。== 

==对于不带进位的循环移位指令而言，如果操作数是8位,那么在移位8次后，操作数就能复原；如果操作是16位,那么在移位16次后，操作数就能复原。对于带进位的循环移 位指令而言，如果操作数是8位，那么在移位 9次后，操作就能复原；如果操作是16位，那 么在移位 17次后，操作就能复原。==

例如：

```assembly
MOV 	CL,9
RCR 	AL,SL
```

通过带进位循环移位指令和其他移位指令的结合，可以实现两个或多个操作数的重 新结合。

例，下面的程序片段实现把AL的高4位与低4位交换：

```assembly
ROL		AL,1
ROL 	AL,1
ROL 	AL,1
ROL 	AL,1
```

例，下面的程序片段实现把AL的最低位送入BL,的最低位，仍保持AL不变；

```assembly
ROR 	BL,1
ROR 	AL,1
RCL		BL,1
ROL		AL,1
```

例，设 DATA1存放在AL的低4位，DATA2存放在AH的低4位,DATA3 存放在 SI的低4位，DATA4存放在SI的高4位。现要把这四个数据合并为16位，并存放到DX 寄存器中。存放要求如下所示。![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20221207/image.75posnofe6o0.webp)

实现上述功能的程序片段如下：

```assembly
....
;把DATA1送到DH的高4位，即DX的高4位
MOV		DH,AL
MOV 	CL,4
SHL 	DH,CL
;把DATA2送到DH的低4位，即DX的11位至18位
AND 	AH,0FH
OR 		DH,AH
;把DATA4送到DL的低4位，即DX的低4位，同时DATA3送到AL的高4位
MOV 	AX,SI
SHL 	AX,1
RCL 	DL,1
SHL 	AX,1
RCL 	DL,1
SHL		AX,1
RCL		DL,1
SHL		AX,1
RCL 	DL,1
;把DATA3送到DL的高4位，即DX的位1至位4
AND		DL,0FH
OR 		DL,AL
....
```

下面程序片段也能实现上述功能请比较

```assembly
....
;把DATA1与DATA2合并，存放到DH
MOV 	CL,4
ROL 	AL,CL
AND 	AX,0FF0H
MOV 	DH,AH
OR 		DH,AL
;把DATA3与DATA4合并，存放到DL
MOV 	AX,SI
ROR 	AX,CL
MOV 	DL,AH	
....
```

## 2.4.8 转移指令

8086/8088提供了大量用于控制程序流程的指令，按功能可分成如下四类： 

1. ==无条件转移指令和条件转移指令；== 
2. ==循环指令；== 
3. ==过程调用和过程返回指令；== 
4. ==软中断指令和中断返回指令。==

==shid==。段内转移是指仅重新设置指令针IP的转移， 由于没有重置CS,所以转移后继续执行的指令仍在同一个代码段中。==条件转移指令和循环指令只能实现段内转移==。段间转移是指不仅重新设置IP,而且重新设置代码段寄存器 CS的转移，由于重置CS,所以转移后继续执行的指令在另一个段中。==软中断指令和中断返回指令总是段间转移==。无条件转移指令和过程调用及返回指令既可以是段内转移,也可以是段间转移。段内转移也称为近转移，而段间转移也称为远转移。

 ==对无条件转移指令和过程调用指令而言，按确定转移目的地址的方式还可分为直接 转移和间接转移两种==。

 下面介绍无条件转移指令、条件转移指令和循环指令。==这些指令均不影响标志==。

### 1.无条件转移指令

#### 1 无条件段内直接转移指令 JMP

```assembly
JMP 	标号
```

这条指令使控制无条件地转移到标号的地址处。例如：

```assembly
NEXT: 	MOV 	AX,CX
		...
		JMP 	NEXT 		;转到NEXT处
		...
		JMP 	OVER 		;转到OVER处
		...
OVER: 	MOV 	AX,1
```

==无条件段内直接转移指令对用的机器指令==格式如下，由操作码和地址差值构成

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20221207/image.onkjzp610hc.webp)

==其中的地址差是程序中该无条件转移指令的下一条指令的开始地址到转移目标地址 （标号所指定指令的开始地址)的差值，由汇编程序在汇编时计算得出==。因此,在执行无条 件段内转移指令时，实际的动作是把指令中的地址差加到指令指针IP上，使IP之内容为 目标地址，从而达到转移的目的。图2.20是无条件段内转移指令的存储和执行示意图。请注意，指令中的地址差值由汇编程序计算得出。

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20221207/image.2yzxf2dj7e80.webp)

段内无条件直接转移指令中的地址差可用一个字节表示，,也可用一个字表示。如果地 址差只要用一个字节表示，就称为短转移;如果地址差要用一个字表示，就称为近转移。一 个字节表示的地址差的范围是-128至十127,所以,如果以转移指令本身为基准,那么短 转移的范围则在一126至+129 之间。==一个字表示的地址差的范围是0至65535,当IP与 地址差之和超过 65535时,那么便在段内反饶(即取 65536的模）==,所以,近转移的范围是整个段。 

如果当汇编程序汇编到该转移指令时能够正确地计算出地址差,那么汇编程序就根 据地址差的大小,决定使用一个字节表示地址差，还是使用一个字表示地址差。例如，上例 中的“JMPNEXT”指令。如果当汇编程序汇编到该指令时还不能计算出地址差,那么汇 编程序就按两字节地址差汇编此转移指令。例如，上例中的“JMP  OVER”指令。对于后 一种情况，如果程序员在写程序时能估计出用一字节就可表示地址差，那么可在标号前加 一个汇编程序操作符SHORT,例如：

```assembly
JMP 	SHORT OVER
```

这样汇编程序就按一字节的地址差汇编此转移指令。当实际的地址差无法用一个字节表示时，汇编程序会发出汇编出现错误的提示信息。

==这种利用目标地址与当前转移指令本身地址之间的差值记录转移目标地址的转移方式也称为相对转移。相对转移有利于程序的浮动。==

#### 2 无条件段间间接转移指令

```assembly
JMP 	OPRD
```

==这条指令使控制无条件地转移到由操作数OPRD的内容给定的目标地址处==。操作数OPRD可以是通用寄存器，也可以是字存储单元。例如：

```assembly
JMP 	CX 					;CX寄存器的内容是IP
JMP 	WORD PTR [1234H]	;子存储单元[1234H]的内容是IP
```

图2.21给出了上述指令的存储和执行示意图。其中假设当前数据段偏移1234H处字单元的内容是5678H。

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20221207/image.i8a1moegoso.webp)

#### 3 无条件段间直接转移指令 JMP FOR PTR

```assembly
JMP 	FAR TPR 	标号
```

==这条指令使控制无条件地转移到标号所对应的地址处。标号前的符号“FAR  PTR”向汇编程序说明这是段间转移。==只有当标号具有远属性，且标号处的指令已先被汇编的情况下,才可省去远属性的说明“FAR  PTR”。

例如

```assembly
JMP		FAR PTR	EXIT		;exit是定义在另一个代码中的标号
```

无条件段间直接转移指令的机器指令格式如下，由操作码及包括段值和偏移的地址构成。

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20221207/image.3g7uvj36ufc0.webp)

==无条件段间直接转移指令的具体动作是把指令中包含的目标地址的段值和偏移分别置人CS和IP。这种在指令中直接包含转移目标地址的转移方式称为绝对转移。==

#### 4 无条件段间间接转移指令 JMP DWORD PTR

```assembly
JMP 	ORPD 
```

==这条指令使控制无条件地转移到由操作数OPRD的内容给定的目标地址处。操作数OPRD必须是双字存储单元==。例如：

```assembly
JMP		DWORD	PTR	[1234H]		;双字存储单元的低字内容送IP
								;双字存储单元的高字内容送CS
```

### 2.条件转移指令

8086/8088提供了大量的条件转移指令，它们根据某标志位或某些标志位的逻辑运算来判别条件是否成立。如果条件成立，则转移，否则继续顺序执行。

所有条件转移都只是段内转移。

条件转移也采用相对转移方式。即通过在IP上加一个地址差的方法实现转移。但条件转移指令中只用一个字节表示地址差,所以,如果以条件转移指令本身作为基准,那么条件转移的范围在一126至十129之间。如果条件转移的目标超出此范围.那么必须借助于无条件转移指令。

条件转移指令不影响标志。

条件转移指令的格式列于表 2.3 中,有些条件转移指令有两个助记符,还有些条件转移指令有三个助记符。使用多个助记符的目的是便于记忆和使用。

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20221207/image.2cyzwz3oz63o.webp)

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20221207/image.1l9k29jphfls.webp)

条件转移指令是用得最多的转移指令。通常，在条件转移指令前，总有用于条件判别的有关指令。

下面的程序片段测试AX的低四位是否全是0,如果均是0,那么使CX=0,否则使CX=-1。

```assembly
	MOV 	CX,1 		;先使CX=-1
	TEST	AX,0FH		;测试AX的低4位
	JNZ		NZERO		;不全为0则转移
	MOV 	CX,0 		;全为0时使CX=0
ZERO: 	....
```

从表 2.3中可见，无符号数之间大小比较后的条件转移指令和有符号数之间的大小比较后的条件转移指令有很大不同。有符号数间的次序关系称为大于(G）、等于(E)和小于(L）;无符号数间的次序关系称为高于(A）、等于(E)和低于(B)。所以，在使用时要注意区分它们,不能混淆。

下面的程序片段实现两个无符号数(设在 AX和 BX中)的比较,把较大的数存放到AX中,把较小的数存放在BX中：

```assembly
	CMP 	AX,BX	
	JAE 	OK 
	XCHG 	AX,BX
OK:	....
```

如果要比较的两个数是有符号数，则可用下面的程序片段：

```assembly
	CMP		AX,BX
	JAE 	OK		;有符号数比较大小转移
	XCHG 	AX,BX
OK: ....
```

从表 2.3 中可见，无符号数之间大小比较后的条件转移指令和有符号数之间的大小比较后的条件转移指令测试的标志完全不同。

不论无符号数还是有符号数，两数是否相等可由ZF标志反映。

当两个无符号数相减时,CF位的情况说明了是否有借位。因此进位标志CF反映两个无符号数比较后的大小关系，所以用于无符号数比较后的条件转移指令(如JB和JAE等）检测标志CF,以判别条件是否成立。但进位标志CF不能反映两个有符号数比较后的大小关系。

两个有符号数比较后的大小关系由符号标志SF和溢出标志OF一起来反。所以用于有符号数比较后的条件转移指令(如JL和JGE等）检测标志SF和OF,以判别条件是否成立。

设要比较的两个不相等的有符号数a和b分别存放在寄存器AX和 BX中,执行指令“CMP AX，BX”后，标志SF及OF的设置情况和两数的大小情况如下：

当没有溢出(OF=0）时,若SF=0,则a>b，若SF=1,则a<b当。产生溢出(OF=1)时,若SF=0,则a<b,若SF=1,则a>b

据此可推断出表 2.3中用于有符号数比较后的条件转移指令所测试的条件。

### 3.循环指令

利用条件转移指令和无条件转移指令可以实现循环,但为了更加方便于循环的实现，8086/8088还提供了四条用于实现循环的循环指令。

循环指令类似于条件转移指令,不仅属于段内转移，而且也采用相对转移的方式，即通过在IP上加一个地址差的方式实现转移。循环指令中也只用一个字节表示地址差，所以,如果以循环指令本身作为基准,那么循环转移的范围在-126 至+129 之间。

循环指令不影响各标志。

#### 1 计算循环指令 LOOP

```assembly
LOOP 标号
```

==这条指令使寄存器CX的值减1,如果结果不等于0,则转移到标号，否则顺序执行LOOP指令后的指令==。该指令类似于如下的两条指令：

```assembly
DEC 	cx;
JNZ 	标号
```

通常在利用LOOP指令构成循环时，先要设置好计数器CX的初值，即循环次数。由于首先进行CX寄存器减1操作，再判结果是否为0,所以最多可循环65536次。

如下程序片段实现把从偏移1000H开始的512个字节的数据复制到从偏移3000H开始的缓冲区中（假设在当前数据段中进行移动）：

```assembly
		MOV		SI,1000H		;置源指针
		MOV		DI,3000H		;置目标指针
		MOV 	CX,512			;置计数器初值
NEXT:	MOV 	AL,[SI]
		INC 	SI
		MOV 	[DI],AL
		INC 	DI
		LOOP 	NEXT			;控制循环
....
```

#### 2 等于/全零循环指令 LOOPZ/LOOPE

```assembly
LOOPZ 	标号
或
LOOPE 	标号
```

==这条指令使寄存器CX的值减1，如果结果不等于0,并且零标志ZF等于1,那么则转移到标号.否则顺序执行。注意指令本身实施的寄存器CX减1操作不影响标志。==

如下的程序片段在字符串中查找第一个非’A'字符。设字符串长度已保存在CX中，并且DS:DI指向字符串。如果找到,那么使 BX指向该非'A'字符，如果找不到,那么使BX=OFFFFH。

```assembly
		...
		MOV 	AL,'A'
		DEC 	D1 
NEXT:   INC 	DI
		CMP 	AL,[DI]
		LOOPE 	NEXT
		MOV		BX.DI
		JNE		OK
		MOV		BX,-1
OK：……
```

#### 3 不等于/非零循环指令 LOOPNE/LOOPNZ

```assembly
LOOPNE 	标号
LOOPNZ 	标号
```

==这条指令使寄存器CX的值减1,如果结果不等于0,并且零标志ZF等于0,那么则转移到标号，否则顺序执行。注意指令本身实施的寄存器CX减1操作不影响标志。==

#### 4 跳转指令 JCXZ

```assembly
JCXZ 	标号
```

例如

```assembly
		...
		JCXZ 	OK		;如果循环计数器为0，就跳过循环
NEXT: 	...				;循环体
		...
		LOOP	NEXT	;根据计数器控制循环
OK: 	...
```

